cliente conecta se --> cria demultiplexer

Demultiplexer:
thread responsavel verificar as notificacoes
thread responsavel pela interacao com util {
--> mostrar menus e enviar respostas ao util
--> enviar e receber do servidor
}

server:
manda pelo clientconnection a info

conexao demultiplexer --> menu

--servidor precisa notificar cliente--
esta logado ?? envias notifi pelo clientConn
se nao guardas no data notifi associadas ao user

--servidor faz um login--
se esta doente
verifica se ut tem notificacoes para receber ? se tem, manda pelo conn
se nao continua



perguntar ao neves :

professor o envio de notificacoes tem que ser como o professor unico ou multi thread??
isto e o servidor pode criar novas threads para enviar as notificacoes ou tem que ser o "mesmo" a fazer

Para o serviço não ficar vulnerável a clientes lentos, não deverá ter threads
do servidor a escrever em mais do que um socket, devendo as escritas serem feitas por threads associadas a esse socket.
--> atribuir uma thread a cada cliente ??

----- dois sockets abordagem ----
socket --> comunicao com cliente
socket --> notificacoes e download de mapa (user especial){

}

 public void download_map() {

     File file = new File("/Users/angelicacunha/Desktop/sample.txt");

     map_lock.lock();

     // Write the content in file
     try(FileWriter fileWriter = new FileWriter(file)) {
         String fileContent=null;
         int N=map.getN();
         String[] headers = { "Localização", "NPessoas"};
         Object[][] data = new Object[N*N][2];
         data[0][0]= "Casa";
         data[0][1]= "0";
         for(int i=1; i<N*N;i++){
             data[i][0] = map.getAdress(i);
             data[i][1] = String.valueOf(map.nr_people(i));
         }
         String table = FlipTableConverters.fromObjects(headers,data);
         fileContent=table;

         System.out.println(fileContent);

         fileWriter.write(fileContent);
     } catch (IOException e) {
         e.printStackTrace();
     } finally {
         map_lock.unlock();
     }
 }
